## 슬로

- Q. 운영체제란?
    - 하드웨어와 사용자 소프트웨어 사이에서 중재자 역할을 하는 소프트웨어를 말합니다.
    - 사용자가 직접 다루기 힘든 각종 하드웨어 자원들을 제어하고 관리해줍니다.
- Q. 프로그램, 프로세스, 스레드, 멀티 프로세스, 멀티 스레드
    - 프로그램
        - 소스 코드가 파일 단위로 저장 장치에 저장되어 있고, 아직 실행되지 않은 상태를 의미합니다.
    - 프로세스
        - 실행 중인 프로그램을 의미하고, 운영체제로부터 시스템 자원을 할당받는 단위 입니다.
        - 특징
            - 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당 받습니다.
            - 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있습니다.
            - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없습니다.
            - 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, Inter-Process Communication)을 사용해야 합니다.
                - 동시에 접근 가능한 메모리 즉, 프로세스들이 공유하는 메모리가 필요하다는 뜻이다.
                - 따라서 컴퓨터 내부에서 보다 효율적으로 정보를 주고 받기 위한 통신의 일종이라고 생각하면 된다.
                - 인터넷 통신을 ipc의 확장으로 이해할 수 있다. (서버 클라이언트 통신과 유사하기 때문)
    - 스레드
        - 프로세스 실행 단위 입니다. 하나의 프로세스가 할당받은 자원을 여러 개의 스레드가 공유하며 사용할 수 있습니다.
        - 특징
            - 스레드는 프로세스 내에서 각각 Stack 영역만 따로 할당받고 Code, Data, Heap 영역은 공유합니다.
            - 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유합니다.
            - 한 스레드가 프로세스 자원을 변경하면, 다른 스레드도 변경 결과를 볼 수 있습니다.
    - 멀티 프로세스
        - 여러 개의 프로세스를 동시에 수행하는 것을 말합니다.
        - 장점
            - 독립된 구조를 가지기 때문에 안정성이 높습니다.
        - 단점
            - 컨텍스트 스위칭을 위한 오버헤드가 발생합니다. 또한 많은 메모리 공간을 차지합니다.
    - 멀티 스레드
        - 하나의 프로세스의 작업을 여러개의 스레드 단위로 분리해서 자원의 생성과 관리의 중복을 최소화하는 것을 말합니다.
        - 장점
            - 자원을 공유하기 때문에 컨텍스트 스위칭이 적고, 오버헤드가 작습니다.
        - 단점
            - 프로세스 내부의 자원을 공유하기 때문에 동시에 자원에 접근했을 때, 문제가 발생할 수 있습니다.
            - 또한, 하나의 스레드가 자신의 데이터 공간을 망가뜨린다면, 해당 데이터를 공유하고 있는 모든 스레드에 문제가 발생합니다.
- Q. 멀티 프로세스 대신 멀티 스레드를 사용하는 이유
    - 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하기 위해서 입니다.
    1. 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어, 시스템 자원을 더 효율적으로 관리할 수 있습니다.
    2. 프로세스간의 통신보다 스레드간의 통신 비용이 적기 때문 입니다.
        - 프로세스는 각각 독립적인 메모리를 가지고 있기 때문에 멀티 프로세스로 동작한다면, 빈번한 컨텍스트 스위칭이 발생합니다. 또한, 프로세스는 별도의 메모리 공간을 만들어줘야 하고, 소켓등을 이용해서 접근해야 하기 때문에 성능저하 및 오버헤드가 발생합니다.
        - 오버헤드
            - 어떤 처리를 하기 위해서 들어가는 간접적인 처리 시간, 메모리 등을 말합니다.
    - 단, 스레드간의 자원공유는 동기화 문제에 신경을 써야합니다. 하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료될 수 있습니다.
    
- Q. 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해주세요
    - 코드 : 실행할 명령어를 저장
    - 데이터 : 프로그램에 필요한 전역 변수나 정적 변수 저장
    - 스택 : 함수 호출에 필요한 스택 프레임 저장
    - 힙 : 사용자가 관리하는 공간으로 메모리가 동적으로 할당되고 해제되는 공간. JAVA에서는 GC가 메모리를 알아서 해제해줍니다.
- Q. 스레드에 스택을 독립적으로 할당하는 이유
    - 스레드마다 독립적인 실행 흐름을 추가하기 위해서 입니다.
    - 스택은 함수 내에서 선언하는 변수, 인자 등을 저장하기 위해서 사용하는 공간입니다.
- Q. PC(Program Counter) 레지스터를 스레드마다 독립적으로 할당하는 이유?
    - 컨텍스트 스위칭 할 때 이전에 어디까지 작업을 수행했는지 기억하기 위해서 스레드마다 독립적으로 할당합니다.
- Q. Thread-safe란?
    - 멀티 스레드 환경에서 공유 자원에 여러 스레드 접근이 있어도 프로그램 실행에 문제가 없음을 의미합니다. (연산 결과의 정합성을 보장될 수 있도록 메모리 가시성이 확보된 상태)
- Q. 컨텍스트 스위칭이란?
    - 하나의 프로세스가 CPU를 사용중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해서, 이전의 프로세스 상태를 보관하고 새로운 프로세스 상태를 적재하는 작업을 말합니다.
        - (주의) 프로세스의 실행 모드만 잠시 사용자 모드에서 커널 모드로 바뀌는 모드 변경은 문맥 교환이라고 하지 않습니다.
        - 이때, CPU는 아무런 일을 하지 않기 때문에 잦은 컨텍스트 스위칭은 성능저하를 일으킬 수 있습니다.
    - 스레드, 프로세스의 컨텍스트 스위칭 동작 방식 비교
        - 스레드는 캐시 메모리나 PCB에 저장해야 하는 내용이 적고, 비워야 하는 내용도 적기 때문에 상대적으로 더 빠른 컨텍스트 스위칭이 일어날 수 있습니다.
    - 언제 발생하는가?
        - 인터럽트, 시스템 콜
- Q. 컨텍스트 스위칭이 필요한 이유
    - 만약, 컴퓨터가 매번 하나의 Task만 처리할 수 있다면, 해당 Task가 끝날 때까지 기다려야합니다. 먼저 처리되는 Task의 시간이 오래걸릴 경우, 그 시간만큼 다음 Task는 무한정 대기해야 합니다.
    - 이러한 문제를 해결하기 위해서 사용합니다.
- Q. 컨텍스트 스위칭의 오버헤드 해결 방안을 설명해주세요.
    - 컨텍스트 스위칭이 자주 발생하지 않도록 다중 프로그래밍의 정도를 낮춥니다.
- Q. PCB(Process Control Block), TCB(Thread Control Block)
    - PCB
        - 운영체제가 프로세스를 제어하기 위한 정보를 저장하는 자료구조를 말합니다.
        - OS의 스케줄러에 의해 컨텍스트 스위칭되는 프로세스의 정보 단위
        - PID(프로세스 식별자), PS(프로세스 상태), PC(프로그램 카운터) 등 프로세스 정보가 있습니다.
    - TCB
        - 스레드 정보를 저장하는 자료구조를 말합니다.
        - 공유 자원이 많은 TCB의 컨텍스트 스위칭 성능이 훨씬 좋습니다. 따라서 멀티 스레드를 사용합니다.
- Q. PCB는 어떻게 관리되는가?
    - Linked List 방식으로 관리합니다.

- Q. 스케줄러란?
    - 어떤 프로세스에게 자원을 할당할지 결정하는 운영체제의 커널 모듈입니다.
- Q. 프로세스 스케줄러에는 어떤 것들이 있나요?
    - 장기 스케줄러 : 어떤 프로세스를 ready queue에 보낼지, 시분할 시스템에서는 잘 안둠
    - 단기 스케줄러 : 어떤 프로세스를 실행시킬지
    - 중기 스케줄러 : 메모리에 공간이 부족한 경우 어떤 프로세스를 swap out할지
- Q. 스케줄링이란?
    - 프로세서에게 필요한 자원을 어떻게 할당할 것인지 선택하는 알고리즘 입니다.
    - 단위 시간당 처리량을 최대화하고, 효율적으로 자원을 할당하기 위한 목적을 가지고 있습니다.
- Q. 스케줄링 단계를 설명해주세요
    - 장기 스케줄러에 의해 어떤 프로세스가 준비 큐에 삽입될지 결정합니다.
        - Ready Queue란 현재 메모리 내에 있으면서 CPU에 의해 실행되기를 기다리는 프로세스의 집합을 의미합니다.
    - 단기 스케줄러는 스케줄링 알고리즘에 따라 CPU를 할당할 프로세스를 선택합니다.
    - 선택된 프로세스는 Running 상태가 되고 작업이 끝나면 Terminated 상태가 됩니다.
    - 중기 스케줄러는 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절합니다.
- Q. 스케줄링 방법에 대해 설명해주세요
    - **선점 스케줄링**
        - 프로세스가 CPU를 점유하고 있어도, 우선 순위가 높은 프로세스가 오면 CPU를 빼앗을 수 있는 방식
        - 우선 순위가 높은 프로세스가 빠르게 처리할 수 있다는 장점이 있지만, 잦은 컨텍스트 스위칭으로 오버헤드가 증가한다는 단점이 있습니다.
        - 종류
            - 우선순위 스케줄링 : 우선순위가 높은 순서대로 처리
            - 라운드로빈 : 동일한 시간의 time quantum만큼 할당
            - Multilevel Queue : 작업을 여러 종류의 큐로 나누어 큐마다 다른 time quantum 할당
            - Multilevel-feedback Queue : Multilevel에서 time quantum을 채우면 다음 level로 내려감
    - **비전섬 스케줄링**
        - 프로세스가 CPU를 점유하고 있는 경우 다른 프로세스가 CPU를 빼앗지 못하는 방식
        - 중간에 가로채지 않기 때문에 응답 시간 예측이 용이하다는 장점이 있지만, 중요한 작업이 오래 기다리게 되는 경우가 발생할 수 있다는 단점이 있습니다.
        - 종류
            - FCFS(First Come First Served) : 큐에 도착한 순서대로 CPU 할당
            - SJF(Shortest Job Firs) : 수행시간이 짧은 것 부터 CPU 할당

- Q. 교착상태, 기아상태
    - 교착상태
        - 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하면서 무한정 기다리는 상황을 말합니다.
    - 기아상태
        - 병행 프로세스에서 프로세스가 실행되는데에 필수적인 자원을 끊임없이 사용하지 못하는 상황을 말합니다.
- Q. 교착상태가 발생하기 위한 조건은?
    
    4가지 중 하나라도 성립하지 않으면 데드락은 발생하지 않습니다.
    
    1. **상호 배제(Mutual exclusion) :** 자원은 한번에 한 프로세스만 사용할 수 있음
    2. **점유 대기(Hold and wait) :** 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
    3. **비선점(No preemption) :** 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
    4. **순환 대기(Circular wait) :** 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함
- Q. 교착상태의 해결법은 무엇인가요?
    1. **예방(prevention)**
        
        교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)
        
        - 상호배제 부정 : 여러 프로세스가 공유 자원 사용
        - 점유대기 부정 : 프로세스 실행전 모든 자원을 할당
        - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
        - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구
    2. **회피(avoidance) -** 교착 상태 발생 시 피해나가는 방법
        
        은행원 알고리즘(Banker's Algorithm)
        
        은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
        
        프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있으면 자원할당, 아니면 할당을 거부하고 다른 프로세스 들이 자원을 해지할때까지 대기하는 방법
        
    3. **탐지(Detection) & 회복**
        
        은행원 알고리즘과 유사한 방식 vs 자원 할당 그래프를 통해 교착 상태를 탐지함
        
        자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함
        
    4. **회복(Recovery) -** 교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법
        
        **프로세스 종료 방법**
        
        - 교착 상태의 프로세스를 모두 중지
        - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
        
        **자원 선점 방법**
        
        - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
        - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점
    5. **무시**
- Q. 회피 기법인 은행원 알고리즘이 뭔지 설명해보세요.
    
    은행원 알고리즘은 은행에서 현금을 할당하는 것에서 유래한 알고리즘입니다.
    
    프로세스가 자원을 요구할때 자원을 할당한 후에도 안정 상태이면 자원을 할당하고, 그렇지 않으면 다른 자원이 해제될때까지 대기했다가 자원을 할당합니다.
    
- Q. 은행원 알고리즘의 단점
    - 할당할 수 있는 자원수가 일정 해야함
    - 항상 불안전 상태를 방지해야 하므로 **자원 이용도가 낮다**
    - **최대 자원 요구량**을 미리 알아야 한다.
    - 프로세스들은 유한한 시간 안에 자원을 반납해야 한다.
- Q. 메모리의 First Fit, Best Fit, Worst Fit에 대해서 설명해 보시오.
    - First-fit : 메모리의 처음부터 검사해서 크기가 충분한 첫 번째 메모리에 할당
    - Next-fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해서 공간을 할당
    - Best-fit : 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당
- Q. 내부 단편화, 외부 단편화
    - 내부 단편화
        - 프로세스가 필요한 양보다 더 큰 메모리 공간에 할당되어 메모리가 낭비되는 것을 말합니다.
    - 외부 단편화
        - 메모리에 프로세스가 할당될 만큼 충분한 공간이 존재하지만 공간이 쪼개져서 프로세스를 넣을 공간이 없는 것을 말합니다.
- Q. 메모리 단편화 해결 기법에 대해 설명해주세요(세그멘테이션, 페이징)
    - 가상 메모리를 이용해서 내부 단편화를 해결하는 세그멘테이션과, 외부 단편화를 해결하는 페이징이 있습니다.
    - 세그멘테이션
        - 메모리를 서로 크기가 다른 논리적인 블록 단위인 세그먼트로 분할해서 메모리를 할당하는 방법입니다.
        - 특징
            - 메모리를 의미 단위로 나누기 때문에 보호와 공유에 효율적입니다.
            - 세그멘트 간에 할당되지 않은 공간이 남는 외부 단편화가 발생할 수 있습니다.
    - 페이징
        - 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재하는 방법입니다.
        - 특징
            - 페이징 기법을 사용하면, 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애 외부 단편화 문제를 해결할 수 있습니다.
            - 하지만, 그만큼 Mapping 과정 또한 늘어나기 때문에 Trade-Off가 발생할 수 있습니다.
            - 또한, 보통 페이지 단위에 알맞게 꽉 채워 쓰는 것이 아니기 때문에 내부 단편화 문제는 여전히 있습니다.
    - [참고](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-14.-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98)
- Q. 페이지 교체 알고리즘 종류에는 어떤 것들이 있나요
    - OPT : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 (실현 가능성 희박)
    - FIFO : 메모리가 할당된 순서대로 페이지를 교체
    - LRU : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
    - LFU : 사용 빈도가 가장 적은 페이지를 교체
    - NUR : 최근에 사용하지 않은 페이지를 교체

- Q. 가상 메모리란?
    - 물리 메모리 크기의 한계를 극복하기 위해서 나온 기술입니다.
    - 프로세스가 실제 메모리의 크기와 상관없이 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 메모리를 사용할 수 있도록 해줍니다.
- Q. 이러한 방식이 어떻게 가능할까?
    - 프로세스를 실행할 때, 필요한 부분만 메모리에 올립니다. 대부분 페이지 단위를 사용하고, 필요한 페이지만 메모리에 올리는 것을 Demand Paging이라고 합니다.
- Q. Demand Paging이란?
    - 현재 필요한 부분만 메모리에 적재하는 것을 말합니다.
- Q. Page Fault란?
    - 지금 실행시켜야 할 페이지가 실제 메모리에 올라와 있지 않는 것을 말합니다.
    - Page Fault로 인한 I/O 작업은 CPU의 효율성을 낮추게 됩니다.

- Q. 동기와 비동기의 차이를 설명해주세요
    - (작업 주체 여러개)
    - 동기/비동기는 두 개 이상의 무엇인가가 시간을 맞춘다/안맞춘다로 구분할 수 있습니다.
    - 동기
        - 메서드 리턴과 결과를 전달받는 시간이 일치하는 명령 실행 방식을 말합니다. 하나의 함수가 끝나는 시간과 바로 다음의 함수가 시작하는 시간이 같습니다.
        - 요청에 대한 결과를 받은 후에야 다음 요청을 진행하는 방식을 말합니다. 결과를 받을 때까지 대기해야 합니다.
    - 비동기
        - 여러 개의 처리가 함께 실행되는 방식입니다.
        - 동기 방식에 비해서 단위시간 당 많은 작업을 처리할 수 있습니다.
        - 하지만, 메모리를 많이 사용하는 작업을 비동기로 처리하게 되면, 과부하가 걸릴 수 있습니다.
- Q. Blocking/Non-blocking
    - (작업이 여러개)
    - 블로킹/논블로킹은 내가 직접 제어할 수 없는 대상(IO/멀티 스레드)을 상대하는 방법에 대한 분류입니다.
    - 블로킹
        - 대상의 작업이 끝날 때까지 제어권을 대상이 가지고 있는 것을 말합니다.
    - 논블로킹
        - 대상의 작업 완료여부와 상관없이 새로운 작얼을 수행하는 것을 말합니다.